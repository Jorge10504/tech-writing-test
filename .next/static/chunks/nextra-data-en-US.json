{"/VortexAPIs/Crypto":{"title":"Crypto","data":{"":"The Crypto Broker service within the Vortex platform offers a suite of cryptographic functionalities designed to secure your application's data. This section details the hashing and decrypting capabilities provided by the Crypto API, ensuring data integrity and confidentiality.","hashing#Hashing":"","overview#Overview":"The Crypto API's hashing function allows for the generation of HMAC (Hash-based Message Authentication Code) hashes of your data. This cryptographic operation ensures data integrity and authenticity by producing a fixed-size string (the hash), which is unique to the input data. HMAC hashing combines the hash function with a secret cryptographic key, adding an additional layer of security.","how-to-perform-hmac-hashing#How to Perform HMAC Hashing":"To hash your data using HMAC, send a POST request with your data payload and specify the operation as \"hash\". You will need to include your API token for authentication.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"hash\"\r\n  },\r\n  \"payload\": \"hash me please\"\r\n}","decrypting-data#Decrypting Data":"","overview-1#Overview":"Decrypting data through the Crypto API requires a valid, signed encryption object. This object typically comes from the Vortex Storage Broker, ensuring a seamless integration between storage and cryptographic operations. The API enforces strict security measures, refusing decryption unless both the signature and a corresponding authentication token are present and valid.","how-to-decrypt-data#How to Decrypt Data":"For decryption, you will pass the encrypted object to the API without the need for additional parameters beyond the necessary authentication headers and the payload. The API then verifies the signature and token before proceeding with decryption.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"decrypt\"\r\n  },\r\n  \"payload\": \"YOUR_SIGNED_DATA\"\r\n}","session-keys#Session Keys":"","overview-2#Overview":"Session keys are an essential aspect of cryptographic operations, providing temporary encryption keys that can be used for a session's duration. The Vortex Crypto API includes a session dispatcher for creating new session keys, simplifying the process of managing encryption keys securely.","generating-new-session-keys#Generating New Session Keys":"To generate a new session key, you only need to make a POST request to the session dispatcher endpoint without any additional parameters. The operation is straightforward and requires minimal input, focusing on ease of use and security.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"session\"\r\n  }\r\n}\nUpon successful execution of this request, the API will return the ID of the newly created session as a string. This session ID can then be used in subsequent cryptographic operations that require or support session-based encryption keys.","encrypting-data#Encrypting Data":"The Vortex Crypto API provides a comprehensive encryption solution that ensures the security of your data. Upon encrypting data, the API returns an encrypted object alongside a hash and mask field. The hashing is performed using the API's HMAC algorithm, which guarantees the integrity and authenticity of your data.","masking-algorithm#Masking Algorithm":"The masking feature offers additional security by revealing only a portion of the encrypted string, based on its length:\nFor strings of 9 characters or more: the last 4 characters are returned.\nFor strings of 5 to 8 characters in length: the last 2 characters are returned.\nFor strings shorter than 5 characters: no characters are returned.\nThis algorithm ensures a balance between security and the need for partial data visibility.","encryption-example#Encryption Example":"When you encrypt data using the Vortex Crypto API, the response includes the encrypted data, a hash value representing the data's integrity, and a mask derived from the encrypted string.Encryption Response Example:\n{\r\n  \"data\": {\r\n    \"key\": 1234567,\r\n    \"iv\": null,\r\n    \"data\": \"c29tZSBlbmNyeXB0ZWQgZGF0YQ==\",\r\n    \"encoding\": \"utf8\"\r\n  },\r\n  \"hash\": \"c29tZSBoYXNoIHZhbHVl\",\r\n  \"mask\": \"1234\"\r\n}\nIn this example, data is the base64 encoded string of the encrypted data. The key and iv (initialization vector) are used in the encryption process, though iv may be null depending on the encryption method used. The hash provides a HMAC hash of the encrypted data, ensuring its integrity, and the mask shows the last few characters of the encrypted string, as defined by the masking algorithm.","aes#AES":"","overview-3#Overview":"AES (Advanced Encryption Standard) is the cornerstone of modern cryptographic security and is the recommended encryption method within the Vortex Crypto API. It offers a balance of performance and security, making it suitable for a wide range of applications. The API supports encryption using the latest version of AES, specifically aes256skv1, as well as providing an alias method for ease of use.","encrypting-with-aes#Encrypting with AES":"","using-aes256skv1#Using aes256skv1":"For those needing to specify the encryption method explicitly, aes256skv1 references the latest version of AES encryption, ensuring you utilize strong and up-to-date cryptographic standards.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes256skv1\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","using-the-aes-alias#Using the aes Alias":"To simplify the encryption process and ensure the use of the latest AES standard, the aes alias can be utilized. This approach automatically selects the most current version of AES implemented by the API.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","encrypting-encoded-data#Encrypting Encoded Data":"When dealing with non-UTF8 text, it's essential to specify the encoding used. This ensures the data is correctly interpreted and encrypted by the API.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\",\r\n    \"encoding\": \"base64\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}","encrypting-with-a-session-key#Encrypting with a Session Key":"For enhanced security and efficiency, you can encrypt data using a session key. This method is particularly useful in scenarios requiring multiple encryptions within the same session.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\",\r\n    \"sessionId\": \"YOUR_SESSION_ID\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}\nThis segment of the Crypto API documentation provides comprehensive details on encrypting data using AES, offering developers flexibility and security for their application's data encryption needs.","hsm#HSM":"","overview-4#Overview":"The Hardware Security Module (HSM) offers an additional layer of security for encrypting data. While AES is preferred for its balance of security and performance, using HSM for encryption is an option within the Vortex Crypto API for scenarios requiring hardware-based security features. The API supports direct encryption with HSM using either a specific version or an alias for the latest implementation.","using-hsm-for-encryption#Using HSM for Encryption":"","encrypting-with-hsmv1#Encrypting with hsmv1":"For users who require specific control over the encryption method, hsmv1 allows for encryption directly against a dedicated Hardware Security Module. This method ensures that data encryption processes are executed within a physically secure environment.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsmv1\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","using-the-hsm-alias#Using the hsm Alias":"The hsm alias points to the most current version of the HSM encryption algorithm implemented by the API. This ensures that your encryption is always up to date with the latest hardware security standards.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","encrypting-encoded-data-with-hsm#Encrypting Encoded Data with HSM":"Similar to AES, when working with non-UTF8 text, specifying the encoding ensures the data is correctly encrypted by the HSM.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\",\r\n    \"encoding\": \"base64\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}","using-your-own-key#Using Your Own Key":"For specific encryption needs, the API allows for the use of a custom HSM key. This key must be pre-configured and recognized by the system.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\",\r\n    \"keyAlias\": \"MY KEY HERE\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}\nThis section of the Crypto API documentation guides you through the process of utilizing HSM for data encryption, offering an alternative to AES encryption for scenarios where hardware-based security is paramount."}},"/VortexAPIs/Payment":{"title":"Payment","data":{"ach#ACH":"Vortex introduces a structured approach to managing Automated Clearing House (ACH) payment requests and responses, ensuring reliable communication over WebSocket. Unlike traditional HTTP request/response models, WebSocket communication lacks inherent request-response pairing. Vortex addresses this by implementing an envelope system, which wraps each ACH payment request, allowing for precise response tracking and handling.","vortex-envelope-for-ach-payments#Vortex Envelope for ACH Payments":"The Vortex Envelope encapsulates ACH payment requests, ensuring each transaction is uniquely identifiable and traceable. This method facilitates the correlation of requests with their corresponding responses, an essential feature for robust payment processing systems.","envelope-structure#Envelope Structure":"{\r\n    \"arguments\": [\r\n        {\r\n            // Payment transaction payload as JSON\r\n        }\r\n    ],\r\n    \"procedure\": \"ach.create\",\r\n    \"class\": \"rpc\",\r\n    \"requestId\": \"UUID\"\r\n}\narguments: Contains the ACH payment request data.\nprocedure: Specifies the action to be performed, e.g., ach.create for creating ACH transactions.\nclass: Indicates the type of message, in this case, rpc for Remote Procedure Call.\nrequestId: A unique identifier (UUID) for the request, facilitating tracking and response pairing.","implementing-ach-payment-requests#Implementing ACH Payment Requests":"Below is a sample payload for an ACH payment request, showcasing the required structure and data elements for processing payments through Vortex.","sample-ach-payment-request#Sample ACH Payment Request":"{\r\n \"arguments\": [\r\n  {\r\n   \"processor\": \"ach.com\",\r\n   \"externalId\": \"477547113252146\",\r\n   \"standardEntryClass\": \"CTX\",\r\n   \"amount\": 20.75,\r\n   \"type\": \"credit\",\r\n   \"subType\": \"none\",\r\n   \"description\": \"TestBuyerA\",\r\n   \"descriptiveDate\": \"2020-07-09T14:52:39.287Z\",\r\n   \"effectiveDate\": \"2020-07-09T14:52:39.287Z\",\r\n   \"company\": {\r\n    \"identification\": \"1472441368\",\r\n    \"name\": \"TestBuyerA\"\r\n   },\r\n   \"receiver\": {\r\n    \"routingNumber\": \"051000020\",\r\n    \"accountNumber\": \"55522244444\",\r\n    \"accountType\": \"checking\",\r\n    \"identification\": \"TestSIDC\",\r\n    \"name\": \"TestSupplierC\"\r\n   },\r\n   \"addenda\": [\r\n    {\"description\": \"TestBuyerA\"}\r\n   ]\r\n  }\r\n ],\r\n \"procedure\": \"ach.create\",\r\n \"class\": \"rpc\",\r\n \"requestId\": \"Field_Level_ACH0.1\"\r\n}","understanding-the-response#Understanding the Response":"Upon successfully processing an ACH payment request, Vortex returns a response that includes a unique ID for the transaction. This ID, which is base64 encoded, serves multiple purposes, including log tracing and transaction tracking.","sample-ach-payment-response#Sample ACH Payment Response":"{\r\n    \"code\": 200,\r\n    \"error\": null,\r\n    \"value\": \"BHMEkrL54KVibGsDGw4yBg==\",\r\n    \"class\": \"response\",\r\n    \"id\": \"9d32128a-f09f-5fec-b65a-5865a21de1d1\",\r\n    \"requestId\": \"Field_Level_ACH0.1\"\r\n}\ncode: HTTP status code indicating the outcome of the request.\nerror: Any error messages, if applicable.\nvalue: The unique ID of the payment request, encoded in base64.\nclass: The type of message, here response, indicating a reply to the initial request.\nid: A unique identifier for the response itself.\nrequestId: The original request ID, allowing for easy matching of requests and responses.","implementing-ach-payments-with-the-vortex-broker-client-library#Implementing ACH Payments with the Vortex Broker Client Library":"Integrating ACH payment functionalities within your applications using the Vortex platform is streamlined with the broker client library. Below are JavaScript examples demonstrating how to initiate ACH payment transactions and retrieve transaction details using the library.","creating-ach-payments#Creating ACH Payments":"This example illustrates the process of creating an ACH payment transaction using the PaymentClient from the Vortex broker client library.\nconst broker = require('@pps/broker-client');\r\nconst client = new broker.PaymentClient('EOS_YOUR_TENANT_TOKEN');\r\n\r\nasync function createACHTransaction() {\r\n    try {\r\n        await client.open();\r\n        const transaction = {\r\n            // Define your transaction details here\r\n            // Refer to the sample payload for structure\r\n        };\r\n        const response = await client.rpc.ach.create(transaction);\r\n        console.log(response.id + ': ' + response.message);\r\n    } finally {\r\n        await client.close();\r\n    }\r\n}\r\n\r\n// Execute the transaction creation function\r\ncreateACHTransaction();\nKey Steps:\nInitialize the PaymentClient with your tenant token.\nOpen a connection to the broker.\nDefine your transaction details.\nCall the ach.create RPC method with your transaction object.\nLog the response, which includes the transaction ID and message.\nEnsure the client connection is closed.","retrieving-ach-payment-information#Retrieving ACH Payment Information":"Retrieving details of an existing ACH transaction is straightforward with the PaymentClient. The following example demonstrates how to query for transaction information based on an external ID.\nconst {PaymentClient} = require('@pps/broker-client');\r\nconst client = new PaymentClient('EOS_TENANT_TOKEN', 'environment');\r\n\r\nasync function retrieveACHTransaction() {\r\n    try {\r\n        await client.open();\r\n        const id = 'some-external-id'; // Specify the external ID of the transaction\r\n        const transactionDetails = await client.rpc.ach.get(id);\r\n        console.log(transactionDetails);\r\n    } finally {\r\n        await client.close();\r\n    }\r\n}\r\n\r\n// Execute the transaction retrieval function\r\nretrieveACHTransaction();\nKey Steps:\nInstantiate the PaymentClient with the appropriate credentials.\nOpen the connection to start communication with the broker.\nUse the ach.get method, passing the external ID of the transaction you wish to query.\nOutput the transaction details to the console or handle as needed.\nClose the client connection to clean up resources.","batch-processing-and-timing#Batch Processing and Timing":"ACH payments are grouped and processed in batches, utilizing the NACHAID (National Automated Clearing House Association ID) for organization. Batch files are generated and transmitted to ACH.com every 15 minutes, starting from the top of the hour. The scheduling ensures that transactions are promptly handled and forwarded for processing. ACH.com, the processing entity, stipulates cutoff times for the submissions, dictating the latest point at which payments can be included in a batch for processing on a given day.","external-id-usage#External ID Usage":"The externalId serves as a unique identifier for transactions, provided by the customer. This ID is integral throughout the transaction's lifecycle, from initiation through to processing by ACH.com. It enables tracking and status updates for the transaction, facilitating communication and query handling between the client and ACH.com.","error-codes-and-troubleshooting#Error Codes and Troubleshooting":"Understanding common error messages and their meanings is crucial for efficient debugging and error handling. Below is a table outlining some potential errors you might encounter when working with ACH payments through the Vortex platform.\nError Message\tDescription\tpayment must be defined\tIndicates that an ACH payment value has not been provided in the transaction request. Ensure your request includes a valid payment object.\tmodel validations failure\tThis error occurs when the schema of the provided ACH payment does not match the expected format. Verify the structure of your payment object against the required schema.\texternalId must be defined\tThe externalId is missing from your request. This ID is crucial for transaction tracking and must be included in both payment submissions and status queries.\tpayment not found\tThe specified ACH payment could not be located with the provided externalId. Ensure the externalId is correct and that the payment has been successfully submitted.\t\nWhen encountering errors, refer to this guide to understand the issue's nature and take appropriate corrective actions. Ensuring that your payment requests are correctly formatted and include all necessary information will minimize errors and streamline the ACH payment process."}},"/VortexAPIs/Storage":{"title":"Storage","data":{"":"The Storage Broker is an integral part of the Vortex platform, providing a robust and flexible solution for managing data storage. It simplifies interactions with various storage mechanisms, whether it be databases, indexes, or other storage entities, through a unified API interface. This section outlines how to make calls to the Storage Broker, detailing the structure of requests and the operations you can perform.","call-to-the-storage-broker#Call to the Storage Broker":"","request-structure#Request Structure":"All interactions with the Storage Broker are conducted through HTTP requests that contain two main components: a dispatch and a payload. The dispatch specifies the instructions for the broker, indicating where and how the data should be handled. The payload carries the data to be processed according to the dispatch instructions.","understanding-the-dispatch#Understanding the Dispatch":"The dispatch within your request plays a crucial role, guiding the Storage Broker on how to manage the data you are sending. It is composed of two essential parts: the entity and the operation.","entity-directing-your-data#Entity: Directing Your Data":"The entity in the dispatch directs your data to the appropriate storage location, such as a table, index, or topic. This routing is based on your configuration and the specified operation. The choice of entity effectively determines where your data is stored or retrieved from within the Vortex ecosystem.\nExample: If the entity is merchant_account and the operation is Search, the broker targets the ElasticSearch index associated with merchant_account.","operation-defining-your-action#Operation: Defining Your Action":"The operation signifies the action you intend to perform with your data. The Storage Broker supports several fundamental operations, including:\nCreate: Adds new data to the specified entity.\nRead: Retrieves data from the specified entity.\nSearch: Conducts a search within the specified entity based on provided criteria.\nUpdate: Modifies existing data within the entity. This operation is similar to create but differs in the payload details.\nDelete: Removes data from the entity. While mechanically similar to create, the intent and payload content vary.\nThe operation part of your dispatch tells the Storage Broker exactly what you want to do with your data, ensuring precise and efficient data management.The payload in requests to the Storage Broker represents the data you wish to manipulate or the criteria for your queries. Tailored to the operation specified in the dispatch, the payload's structure varies, reflecting the nature of the intended action—whether creating, updating, deleting, reading, or searching data.","the-role-of-the-payload#The Role of the Payload":"The payload is the core component of your request, containing either the data for creation or modification or the query parameters for retrieval or search operations. Its format and content are contingent upon the operation being performed, as outlined below:","read-operations#Read Operations":"For read operations, particularly from databases like MemSQL, the payload is structured as a query using the RQL (Resource Query Language). RQL is a powerful and flexible query language designed to facilitate complex querying operations.\nLearn more about RQL: RQL Language Guide","search-operations#Search Operations":"Search operations, especially when interacting with Elasticsearch, leverage the Query DSL (Domain-Specific Language) provided by Elasticsearch. This language enables the crafting of intricate search queries to navigate and retrieve data from Elasticsearch indices efficiently.\nLearn more about Query DSL: Elasticsearch Query DSL","create-update-and-delete-operations#Create, Update, and Delete Operations":"For operations that modify data—such as creating, updating, or deleting—the payload is a JSON object representing the data you wish to work with. This data is passed directly to the broker, which then processes it according to the specified operation and entity.","example-broker-call#Example Broker Call":"An example of a broker call for a read operation on the merchant_account entity is shown below. This example demonstrates how the dispatch and payload are combined within a single request to perform a specific action—in this case, reading data using an RQL query.Example:\nPOST https://pps-storage-api-broker:80\r\n{\r\n \"dispatch\": {\r\n   \"entity\": \"merchant_account\",\r\n   \"operation\": \"read\"\r\n },\r\n \"payload\": \"eq(id,2933752)\"\r\n}\nIn this example, the payload eq(id,2933752) instructs the Storage Broker to retrieve records from the merchant_account entity where the id equals 2933752.","data-persistence-flow-overview#Data Persistence Flow Overview":"Understanding the data persistence flow is crucial for developers working with the Vortex Storage API. This flow outlines the journey of data from the moment it is sent to the Storage Broker, through processing and validation stages, to its eventual persistence and notification. Below is a visual representation of this flow:","data-flow-diagram#Data Flow Diagram":"This diagram illustrates the path data takes within the system, highlighting key stages such as processing, validation, persistence, and notification.","processing-stage#Processing Stage":"When delta envelopes (data updates) are sent to the Storage Broker, they enter the processing stage. This stage involves several critical steps to ensure data integrity and security:\nEntity Configuration Lookup: The system retrieves the configuration for the entity based on the tenant's API settings.\nValidation: The data undergoes validation checks to ensure compliance with defined schemas and rules.\nEntity Verification: The system verifies that the tenant has an entity matching the provided key.\nPersistence Topic Location: It locates the appropriate topic for data persistence related to the specified entity.\nPermission Checks: The broker checks if the user or role has sufficient permissions for the operation.\nApply Permission Restrictions: Any necessary permission restrictions are applied to the delta payload.\nData Encryption: Sensitive or critical data within the payload is encrypted to maintain confidentiality.","notification-stage#Notification Stage":"After data has been successfully processed and persisted, it moves to the notification stage. This stage involves alerting relevant systems or users about the update. However, if no notification methods have been configured for the entity, this stage will be skipped, streamlining the process for entities where notifications are not necessary.","action-topics#Action Topics":"For tenants requiring updates on performed actions, action topics can be configured. These topics provide a channel for receiving notifications about data changes, with two types of action topics available:\nGlobal Action Topic: Receives notifications about every persisted message, regardless of the message's origin.\nLocal Action Topic: Only receives messages originating from the same data center, offering localized updates while being identical in function to the global topic.\nAction topics are entity-specific and optional, offering flexibility in how updates and notifications are handled.The Vortex Storage Broker API now supports WebSocket communication, enabling real-time, bidirectional communication between clients and the Storage Broker. This enhancement is facilitated through the StorageWsClient, an extension of the basic WebSocket client tailored for the Storage API. This document outlines the setup, configuration, and usage of the StorageWsClient.","features#Features":"The StorageWsClient integrates several plugins to enhance its functionality, ensuring efficient and reliable communication with the Storage Broker:\nProtocol Validation Plugin: Ensures that communication adheres to predefined protocols, enhancing security and data integrity.\nSmart Reconnection Plugin: Automatically attempts to re-establish connections in case of disconnection, ensuring continuous communication without manual intervention.\nRPC Plugin: Enables Remote Procedure Calls (RPC), allowing clients to execute functions on the server side directly from the client side.","initialization#Initialization":"","creating-a-new-storagewsclient#Creating a New StorageWsClient":"To initiate communication with the Storage Broker via WebSocket, a new StorageWsClient instance must be created. This instance requires specific configuration parameters to establish the connection successfully.","initializing-a-storagewsclient-instance#Initializing a StorageWsClient Instance":"Parameters:\nName\tType\tAttributes\tDefault\tDescription\ttenantToken\tstring\t\t\tTenant API Token for secure communication with tenant services. Defaults to reading from secrets.\tvirtualEnv\tstring\tOptional\t\tSpecifies the virtual environment for the broker, aiding in environment-specific configurations.\tagent\texternal:ServiceDiscoveryAgent\tOptional\trequire('@pps/svc-discovery').agent\tService discovery agent to locate a broker instance, streamlining the connection process.","example#Example":"const {StorageWsClient} = require('@pps/broker-client');\r\nconst client = new StorageWsClient(tenantToken, virtualEnv);\r\nawait client.open(); // Establish the WebSocket connection\r\n// Now you can start sending RPCs or other WebSocket communications\r\nawait client.close(); // Close the WebSocket connection when done","utilizing-the-global-tenant-token#Utilizing the Global Tenant Token":"For convenience, the StorageWsClient can also be instantiated using a global tenant token, reducing the need for manual token management.","initializing-storagewsclient-with-global-tenant-token#Initializing StorageWsClient with Global Tenant Token":"Returns a Promise that resolves to a StorageWsClient instance, configured with the global tenant token.Parameters:\nName\tType\tAttributes\tDescription\tvirtualEnv\tstring\tOptional\tVirtual environment name for specific configuration.\tagent\texternal:ServiceDiscoveryAgent\tOptional\tService discovery agent for locating a broker instance efficiently.","return-value#Return Value":"Type: Promise.<module:broker-client.StorageWsClient>\nDescription: Asynchronously returns a new StorageWsClient instance using the globally configured tenant token."}},"/Other_Products":{"title":"PRTH Products","data":{"":"PRTH extends beyond the innovative Vortex APIs to offer a suite of comprehensive solutions designed to enhance your business operations and financial transactions. Dive into our premier products tailored for developers, businesses, and merchants aiming to elevate their commerce and payment processes.","passport-unified-commerce-platform#Passport: Unified Commerce Platform":"Integrate your applications seamlessly with Passport, our Unified Commerce Platform that simplifies and secures the way you collect, store, and send money. With a straightforward API integration, tap into a world of lower costs, reduced complexity, and full regulatory compliance. Passport is your gateway to a hassle-free commerce experience.","cpx-automate-accounts-payable#CPX: Automate Accounts Payable":"Transform your accounts payable (AP) with CPX, a revolutionary B2B Payments Application. Automate your AP processes entirely, reduce operational costs, and unlock cash-back opportunities when paying suppliers. CPX elevates your B2B payments with a complete platform that boosts monetized payments and enhances productivity.","merchant-smb-payments-application#Merchant: SMB Payments Application":"MX™ Merchant represents the pinnacle in payment-processing solutions, providing an all-encompassing suite of services from billing and sales tracking to customer engagement. Designed for small and medium-sized businesses, MX™ Merchant simplifies your operations, consolidating all critical aspects of your business into one comprehensive source.","cftpay-secure-payment-processing#CFTPay: Secure Payment Processing":"Empower your consumer finance business with CFTPay, a platform that combines best-in-class technology with unparalleled support. Tailored for debt settlement, consumer finance, and wellness sectors, CFTPay offers secure payment processing, FDIC-insured escrow account banking, transaction monitoring, and much more. Enhance your platform with CFTPay and navigate the financial landscape with confidence.Eager to dive deeper into what PRTH has to offer? Our comprehensive webpage is your gateway to a wealth of information on our products and services. Follow these simple steps to explore our offerings and see how we can transform your business processes and payment solutions.","how-to-explore-prth-products-and-services#How to Explore PRTH Products and Services":"Navigate to our homepage:\nBegin your journey at Priority Commerce, where innovation meets simplicity.\nClick on 'What We Offer':\nDiscover the wide range of solutions designed to empower your business, from payment processing to comprehensive commerce platforms.\nExplore our product suite:\nDelve into our innovative products and find the perfect fit for your business needs.\nShould you have any inquiries or need further assistance, our dedicated support team is always here to help. Thank you for considering PRTH as your partner in business and payment solutions."}}}