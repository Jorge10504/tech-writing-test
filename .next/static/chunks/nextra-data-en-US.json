{"/":{"title":"Vortex API Documentation: Enhanced Version","data":{"":"Welcome to the Enhanced Version of the Vortex API Documentation. This document is designed to provide developers with a comprehensive guide to integrating and utilizing the Vortex APIs effectively. Developed by Christian Arango, a technical writer at PRTH - Vortex, this version aims to offer a refined, user-friendly experience for navigating the complexities of our APIs.","disclaimer#Disclaimer":"ðŸš§ Important: This document is an enhanced, unofficial version of the Vortex API documentation. It is intended for informational purposes only and should not be replicated or used as a substitute for the authorized documentation.For access to the official Vortex API documentation, including detailed API references and additional resources, please visit the Vortex Documentation Dedicated Hub.","objective#Objective":"The Vortex APIs - Crypto, Payment, and Storage - serve as the backbone for a wide range of applications, enabling developers to build robust, secure, and scalable digital solutions. Recognizing the importance of clear and accessible documentation, this enhanced version seeks to simplify the integration process by offering:\nA streamlined structure and format for easier navigation\nDirect and jargon-free language to appeal to developers of all levels\nPractical implementation guides and code examples in multiple programming languages\nAn aesthetically pleasing presentation in markdown format, with syntax highlighting for code","getting-started#Getting Started":"This documentation is divided into several key sections to guide you through the process of integrating the Vortex APIs into your projects:\nIntroduction and General Information: An overview of the Vortex product suite and the benefits of using our APIs.\nImplementation Guide: Step-by-step instructions on getting started with the APIs, including prerequisites and authentication.\nAPI Overview: Detailed descriptions of the Storage, Crypto, and Payment APIs, their functions, and how they can enhance your applications.\nCode Examples: Sample code snippets in JavaScript, Python, and more, demonstrating common use cases and integration strategies.","feedback-and-contributions#Feedback and Contributions":"We believe in continuous improvement and value your feedback. If you have suggestions, comments, or identify any discrepancies in this documentation, please let us know. Your input is crucial in helping us enhance the quality and accuracy of our resources."}},"/VortexAPIs/Crypto":{"title":"Crypto","data":{"":"The Crypto Broker service within the Vortex platform offers a suite of cryptographic functionalities designed to secure your application's data. This section details the hashing and decrypting capabilities provided by the Crypto API, ensuring data integrity and confidentiality.","hashing#Hashing":"","overview#Overview":"The Crypto API's hashing function allows for the generation of HMAC (Hash-based Message Authentication Code) hashes of your data. This cryptographic operation ensures data integrity and authenticity by producing a fixed-size string (the hash), which is unique to the input data. HMAC hashing combines the hash function with a secret cryptographic key, adding an additional layer of security.","how-to-perform-hmac-hashing#How to Perform HMAC Hashing":"To hash your data using HMAC, send a POST request with your data payload and specify the operation as \"hash\". You will need to include your API token for authentication.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"hash\"\r\n  },\r\n  \"payload\": \"hash me please\"\r\n}","decrypting-data#Decrypting Data":"","overview-1#Overview":"Decrypting data through the Crypto API requires a valid, signed encryption object. This object typically comes from the Vortex Storage Broker, ensuring a seamless integration between storage and cryptographic operations. The API enforces strict security measures, refusing decryption unless both the signature and a corresponding authentication token are present and valid.","how-to-decrypt-data#How to Decrypt Data":"For decryption, you will pass the encrypted object to the API without the need for additional parameters beyond the necessary authentication headers and the payload. The API then verifies the signature and token before proceeding with decryption.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"decrypt\"\r\n  },\r\n  \"payload\": \"YOUR_SIGNED_DATA\"\r\n}","session-keys#Session Keys":"","overview-2#Overview":"Session keys are an essential aspect of cryptographic operations, providing temporary encryption keys that can be used for a session's duration. The Vortex Crypto API includes a session dispatcher for creating new session keys, simplifying the process of managing encryption keys securely.","generating-new-session-keys#Generating New Session Keys":"To generate a new session key, you only need to make a POST request to the session dispatcher endpoint without any additional parameters. The operation is straightforward and requires minimal input, focusing on ease of use and security.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"session\"\r\n  }\r\n}\nUpon successful execution of this request, the API will return the ID of the newly created session as a string. This session ID can then be used in subsequent cryptographic operations that require or support session-based encryption keys.","encrypting-data#Encrypting Data":"The Vortex Crypto API provides a comprehensive encryption solution that ensures the security of your data. Upon encrypting data, the API returns an encrypted object alongside a hash and mask field. The hashing is performed using the API's HMAC algorithm, which guarantees the integrity and authenticity of your data.","masking-algorithm#Masking Algorithm":"The masking feature offers additional security by revealing only a portion of the encrypted string, based on its length:\nFor strings of 9 characters or more: the last 4 characters are returned.\nFor strings of 5 to 8 characters in length: the last 2 characters are returned.\nFor strings shorter than 5 characters: no characters are returned.\nThis algorithm ensures a balance between security and the need for partial data visibility.","encryption-example#Encryption Example":"When you encrypt data using the Vortex Crypto API, the response includes the encrypted data, a hash value representing the data's integrity, and a mask derived from the encrypted string.Encryption Response Example:\n{\r\n  \"data\": {\r\n    \"key\": 1234567,\r\n    \"iv\": null,\r\n    \"data\": \"c29tZSBlbmNyeXB0ZWQgZGF0YQ==\",\r\n    \"encoding\": \"utf8\"\r\n  },\r\n  \"hash\": \"c29tZSBoYXNoIHZhbHVl\",\r\n  \"mask\": \"1234\"\r\n}\nIn this example, data is the base64 encoded string of the encrypted data. The key and iv (initialization vector) are used in the encryption process, though iv may be null depending on the encryption method used. The hash provides a HMAC hash of the encrypted data, ensuring its integrity, and the mask shows the last few characters of the encrypted string, as defined by the masking algorithm.","aes#AES":"","overview-3#Overview":"AES (Advanced Encryption Standard) is the cornerstone of modern cryptographic security and is the recommended encryption method within the Vortex Crypto API. It offers a balance of performance and security, making it suitable for a wide range of applications. The API supports encryption using the latest version of AES, specifically aes256skv1, as well as providing an alias method for ease of use.","encrypting-with-aes#Encrypting with AES":"","using-aes256skv1#Using aes256skv1":"For those needing to specify the encryption method explicitly, aes256skv1 references the latest version of AES encryption, ensuring you utilize strong and up-to-date cryptographic standards.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes256skv1\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","using-the-aes-alias#Using the aes Alias":"To simplify the encryption process and ensure the use of the latest AES standard, the aes alias can be utilized. This approach automatically selects the most current version of AES implemented by the API.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","encrypting-encoded-data#Encrypting Encoded Data":"When dealing with non-UTF8 text, it's essential to specify the encoding used. This ensures the data is correctly interpreted and encrypted by the API.Request Example:\nPOST /dispatch HTTP/1.1\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\",\r\n    \"encoding\": \"base64\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}","encrypting-with-a-session-key#Encrypting with a Session Key":"For enhanced security and efficiency, you can encrypt data using a session key. This method is particularly useful in scenarios requiring multiple encryptions within the same session.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"aes\",\r\n    \"sessionId\": \"YOUR_SESSION_ID\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}\nThis segment of the Crypto API documentation provides comprehensive details on encrypting data using AES, offering developers flexibility and security for their application's data encryption needs.","hsm#HSM":"","overview-4#Overview":"The Hardware Security Module (HSM) offers an additional layer of security for encrypting data. While AES is preferred for its balance of security and performance, using HSM for encryption is an option within the Vortex Crypto API for scenarios requiring hardware-based security features. The API supports direct encryption with HSM using either a specific version or an alias for the latest implementation.","using-hsm-for-encryption#Using HSM for Encryption":"","encrypting-with-hsmv1#Encrypting with hsmv1":"For users who require specific control over the encryption method, hsmv1 allows for encryption directly against a dedicated Hardware Security Module. This method ensures that data encryption processes are executed within a physically secure environment.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsmv1\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","using-the-hsm-alias#Using the hsm Alias":"The hsm alias points to the most current version of the HSM encryption algorithm implemented by the API. This ensures that your encryption is always up to date with the latest hardware security standards.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}","encrypting-encoded-data-with-hsm#Encrypting Encoded Data with HSM":"Similar to AES, when working with non-UTF8 text, specifying the encoding ensures the data is correctly encrypted by the HSM.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\",\r\n    \"encoding\": \"base64\"\r\n  },\r\n  \"payload\": \"bXkgdGVzdCBkYXRh\"\r\n}","using-your-own-key#Using Your Own Key":"For specific encryption needs, the API allows for the use of a custom HSM key. This key must be pre-configured and recognized by the system.Request Example:\nPOST /dispatch HTTP/1.1\r\nHost: localhost:9200\r\nRequest-ID: YOUR_REQUEST_ID\r\nAuthorization: Bearer YOUR_API_TOKEN\r\nContent-Type: application/json\r\n\r\n{\r\n  \"dispatch\": {\r\n    \"operation\": \"encrypt\",\r\n    \"method\": \"hsm\",\r\n    \"keyAlias\": \"MY KEY HERE\"\r\n  },\r\n  \"payload\": \"my test data\"\r\n}\nThis section of the Crypto API documentation guides you through the process of utilizing HSM for data encryption, offering an alternative to AES encryption for scenarios where hardware-based security is paramount."}},"/VortexAPIs/Storage":{"title":"Storage","data":{"":"The Storage Broker is an integral part of the Vortex platform, providing a robust and flexible solution for managing data storage. It simplifies interactions with various storage mechanisms, whether it be databases, indexes, or other storage entities, through a unified API interface. This section outlines how to make calls to the Storage Broker, detailing the structure of requests and the operations you can perform.","call-to-the-storage-broker#Call to the Storage Broker":"","request-structure#Request Structure":"All interactions with the Storage Broker are conducted through HTTP requests that contain two main components: a dispatch and a payload. The dispatch specifies the instructions for the broker, indicating where and how the data should be handled. The payload carries the data to be processed according to the dispatch instructions.","understanding-the-dispatch#Understanding the Dispatch":"The dispatch within your request plays a crucial role, guiding the Storage Broker on how to manage the data you are sending. It is composed of two essential parts: the entity and the operation.","entity-directing-your-data#Entity: Directing Your Data":"The entity in the dispatch directs your data to the appropriate storage location, such as a table, index, or topic. This routing is based on your configuration and the specified operation. The choice of entity effectively determines where your data is stored or retrieved from within the Vortex ecosystem.\nExample: If the entity is merchant_account and the operation is Search, the broker targets the ElasticSearch index associated with merchant_account.","operation-defining-your-action#Operation: Defining Your Action":"The operation signifies the action you intend to perform with your data. The Storage Broker supports several fundamental operations, including:\nCreate: Adds new data to the specified entity.\nRead: Retrieves data from the specified entity.\nSearch: Conducts a search within the specified entity based on provided criteria.\nUpdate: Modifies existing data within the entity. This operation is similar to create but differs in the payload details.\nDelete: Removes data from the entity. While mechanically similar to create, the intent and payload content vary.\nThe operation part of your dispatch tells the Storage Broker exactly what you want to do with your data, ensuring precise and efficient data management.The payload in requests to the Storage Broker represents the data you wish to manipulate or the criteria for your queries. Tailored to the operation specified in the dispatch, the payload's structure varies, reflecting the nature of the intended actionâ€”whether creating, updating, deleting, reading, or searching data.","the-role-of-the-payload#The Role of the Payload":"The payload is the core component of your request, containing either the data for creation or modification or the query parameters for retrieval or search operations. Its format and content are contingent upon the operation being performed, as outlined below:","read-operations#Read Operations":"For read operations, particularly from databases like MemSQL, the payload is structured as a query using the RQL (Resource Query Language). RQL is a powerful and flexible query language designed to facilitate complex querying operations.\nLearn more about RQL: RQL Language Guide","search-operations#Search Operations":"Search operations, especially when interacting with Elasticsearch, leverage the Query DSL (Domain-Specific Language) provided by Elasticsearch. This language enables the crafting of intricate search queries to navigate and retrieve data from Elasticsearch indices efficiently.\nLearn more about Query DSL: Elasticsearch Query DSL","create-update-and-delete-operations#Create, Update, and Delete Operations":"For operations that modify dataâ€”such as creating, updating, or deletingâ€”the payload is a JSON object representing the data you wish to work with. This data is passed directly to the broker, which then processes it according to the specified operation and entity.","example-broker-call#Example Broker Call":"An example of a broker call for a read operation on the merchant_account entity is shown below. This example demonstrates how the dispatch and payload are combined within a single request to perform a specific actionâ€”in this case, reading data using an RQL query.Example:\nPOST https://pps-storage-api-broker:80\r\n{\r\n \"dispatch\": {\r\n   \"entity\": \"merchant_account\",\r\n   \"operation\": \"read\"\r\n },\r\n \"payload\": \"eq(id,2933752)\"\r\n}\nIn this example, the payload eq(id,2933752) instructs the Storage Broker to retrieve records from the merchant_account entity where the id equals 2933752.","data-persistence-flow-overview#Data Persistence Flow Overview":"Understanding the data persistence flow is crucial for developers working with the Vortex Storage API. This flow outlines the journey of data from the moment it is sent to the Storage Broker, through processing and validation stages, to its eventual persistence and notification. Below is a visual representation of this flow:","data-flow-diagram#Data Flow Diagram":"This diagram illustrates the path data takes within the system, highlighting key stages such as processing, validation, persistence, and notification.","processing-stage#Processing Stage":"When delta envelopes (data updates) are sent to the Storage Broker, they enter the processing stage. This stage involves several critical steps to ensure data integrity and security:\nEntity Configuration Lookup: The system retrieves the configuration for the entity based on the tenant's API settings.\nValidation: The data undergoes validation checks to ensure compliance with defined schemas and rules.\nEntity Verification: The system verifies that the tenant has an entity matching the provided key.\nPersistence Topic Location: It locates the appropriate topic for data persistence related to the specified entity.\nPermission Checks: The broker checks if the user or role has sufficient permissions for the operation.\nApply Permission Restrictions: Any necessary permission restrictions are applied to the delta payload.\nData Encryption: Sensitive or critical data within the payload is encrypted to maintain confidentiality.","notification-stage#Notification Stage":"After data has been successfully processed and persisted, it moves to the notification stage. This stage involves alerting relevant systems or users about the update. However, if no notification methods have been configured for the entity, this stage will be skipped, streamlining the process for entities where notifications are not necessary.","action-topics#Action Topics":"For tenants requiring updates on performed actions, action topics can be configured. These topics provide a channel for receiving notifications about data changes, with two types of action topics available:\nGlobal Action Topic: Receives notifications about every persisted message, regardless of the message's origin.\nLocal Action Topic: Only receives messages originating from the same data center, offering localized updates while being identical in function to the global topic.\nAction topics are entity-specific and optional, offering flexibility in how updates and notifications are handled.The Vortex Storage Broker API now supports WebSocket communication, enabling real-time, bidirectional communication between clients and the Storage Broker. This enhancement is facilitated through the StorageWsClient, an extension of the basic WebSocket client tailored for the Storage API. This document outlines the setup, configuration, and usage of the StorageWsClient.","features#Features":"The StorageWsClient integrates several plugins to enhance its functionality, ensuring efficient and reliable communication with the Storage Broker:\nProtocol Validation Plugin: Ensures that communication adheres to predefined protocols, enhancing security and data integrity.\nSmart Reconnection Plugin: Automatically attempts to re-establish connections in case of disconnection, ensuring continuous communication without manual intervention.\nRPC Plugin: Enables Remote Procedure Calls (RPC), allowing clients to execute functions on the server side directly from the client side.","initialization#Initialization":"","creating-a-new-storagewsclient#Creating a New StorageWsClient":"To initiate communication with the Storage Broker via WebSocket, a new StorageWsClient instance must be created. This instance requires specific configuration parameters to establish the connection successfully.","initializing-a-storagewsclient-instance#Initializing a StorageWsClient Instance":"Parameters:\nName\tType\tAttributes\tDefault\tDescription\ttenantToken\tstring\t\t\tTenant API Token for secure communication with tenant services. Defaults to reading from secrets.\tvirtualEnv\tstring\tOptional\t\tSpecifies the virtual environment for the broker, aiding in environment-specific configurations.\tagent\texternal:ServiceDiscoveryAgent\tOptional\trequire('@pps/svc-discovery').agent\tService discovery agent to locate a broker instance, streamlining the connection process.","example#Example":"const {StorageWsClient} = require('@pps/broker-client');\r\nconst client = new StorageWsClient(tenantToken, virtualEnv);\r\nawait client.open(); // Establish the WebSocket connection\r\n// Now you can start sending RPCs or other WebSocket communications\r\nawait client.close(); // Close the WebSocket connection when done","utilizing-the-global-tenant-token#Utilizing the Global Tenant Token":"For convenience, the StorageWsClient can also be instantiated using a global tenant token, reducing the need for manual token management.","initializing-storagewsclient-with-global-tenant-token#Initializing StorageWsClient with Global Tenant Token":"Returns a Promise that resolves to a StorageWsClient instance, configured with the global tenant token.Parameters:\nName\tType\tAttributes\tDescription\tvirtualEnv\tstring\tOptional\tVirtual environment name for specific configuration.\tagent\texternal:ServiceDiscoveryAgent\tOptional\tService discovery agent for locating a broker instance efficiently.","return-value#Return Value":"Type: Promise.<module:broker-client.StorageWsClient>\nDescription: Asynchronously returns a new StorageWsClient instance using the globally configured tenant token."}}}